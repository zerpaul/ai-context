{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://aicontext/./src/extension.ts","webpack://aicontext/external commonjs \"vscode\"","webpack://aicontext/external node-commonjs \"fs/promises\"","webpack://aicontext/external node-commonjs \"path\"","webpack://aicontext/webpack/bootstrap","webpack://aicontext/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('AI Context Extractor is now active');\n\n    const disposable = vscode.commands.registerCommand('aicontext.extractFolder', async (uri: vscode.Uri, selectedFiles?: vscode.Uri[]) => {\n        try {\n            // Handle multi-selection case\n            if (selectedFiles && selectedFiles.length > 0) {\n                const firstFile = selectedFiles[0];\n                const folderPath = path.dirname(firstFile.fsPath);\n                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n                const outputFileName = `selected_files_${timestamp}.txt`;\n                const outputPath = path.join(folderPath, outputFileName);\n\n                await processFiles(selectedFiles, outputPath, folderPath);\n                await showSuccessMessage(outputFileName, outputPath);\n                return;\n            }\n\n            // Handle single file/folder case\n            if (!uri) {\n                vscode.window.showErrorMessage('Please select a file or folder to extract context from');\n                return;\n            }\n\n            const stats = await fs.stat(uri.fsPath);\n            if (stats.isFile()) {\n                // Single file processing\n                const folderPath = path.dirname(uri.fsPath);\n                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n                const outputFileName = `single_file_${timestamp}.txt`;\n                const outputPath = path.join(folderPath, outputFileName);\n\n                await processFiles([uri], outputPath, folderPath);\n                await showSuccessMessage(outputFileName, outputPath);\n            } else {\n                // Folder processing (existing functionality)\n                const folderPath = uri.fsPath;\n                const folderName = path.basename(folderPath);\n                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n                const outputFileName = `${folderName}_${timestamp}.txt`;\n                const outputPath = path.join(folderPath, outputFileName);\n\n                await processFolderContent(folderPath, outputPath);\n                await showSuccessMessage(outputFileName, outputPath);\n            }\n        } catch (error) {\n            vscode.window.showErrorMessage(`Error extracting context: ${error}`);\n        }\n    });\n\n    context.subscriptions.push(disposable);\n}\n\nasync function processFiles(files: vscode.Uri[], outputPath: string, rootPath: string): Promise<void> {\n    await vscode.window.withProgress({\n        location: vscode.ProgressLocation.Notification,\n        title: \"Extracting file context...\",\n        cancellable: true\n    }, async (progress) => {\n        let output = 'FILE EXTRACTION\\n===============\\n';\n        output += `Root Path: ${rootPath}\\n`;\n        output += `Scan Date: ${new Date().toISOString()}\\n`;\n        output += `Total Files: ${files.length}\\n\\n`;\n\n        output += 'SELECTED FILES\\n==============\\n';\n        files.forEach(file => {\n            output += `${path.relative(rootPath, file.fsPath)}\\n`;\n        });\n        output += '\\n';\n\n        output += 'FILE CONTENTS\\n=============\\n\\n';\n\n        let processedFiles = 0;\n        for (const file of files) {\n            try {\n                const content = await fs.readFile(file.fsPath, 'utf8');\n                const separator = '='.repeat(80);\n                output += `${separator}\\n`;\n                output += `Absolute Path: ${file.fsPath}\\n`;\n                output += `Relative Path: ${path.relative(rootPath, file.fsPath)}\\n`;\n                output += `${separator}\\n\\n`;\n                output += content;\n                output += '\\n\\n';\n\n                processedFiles++;\n                progress.report({\n                    message: `Processing files... (${processedFiles}/${files.length})`,\n                    increment: (100 / files.length)\n                });\n            } catch (error) {\n                output += `Error reading file ${file.fsPath}: ${error}\\n\\n`;\n            }\n        }\n\n        await fs.writeFile(outputPath, output, 'utf8');\n    });\n}\n\nasync function processFolderContent(folderPath: string, outputPath: string): Promise<void> {\n    await vscode.window.withProgress({\n        location: vscode.ProgressLocation.Notification,\n        title: \"Extracting folder context...\",\n        cancellable: true\n    }, async (progress) => {\n        let output = 'PROJECT METADATA\\n===============\\n';\n        output += `Project Root: ${folderPath}\\n`;\n        output += `Scan Date: ${new Date().toISOString()}\\n`;\n\n        const files = await getAllFiles(folderPath);\n        output += `Total Files: ${files.length}\\n\\n`;\n\n        progress.report({ message: \"Building directory structure...\" });\n\n        output += 'DIRECTORY STRUCTURE\\n==================\\n';\n        const structure = new Map<string, string[]>();\n        \n        files.forEach(file => {\n            const relPath = path.relative(folderPath, path.dirname(file));\n            const fileName = path.basename(file);\n            \n            if (!structure.has(relPath)) {\n                structure.set(relPath, []);\n            }\n            structure.get(relPath)?.push(fileName);\n        });\n\n        for (const [dir, fileList] of structure) {\n            output += dir ? `/${dir}/\\n` : '/\\n';\n            fileList.forEach(file => {\n                output += `  └── ${file}\\n`;\n            });\n        }\n        output += '\\n';\n\n        progress.report({ message: \"Reading file contents...\" });\n\n        output += 'FILE CONTENTS\\n=============\\n\\n';\n        \n        let processedFiles = 0;\n        for (const file of files) {\n            try {\n                const content = await fs.readFile(file, 'utf8');\n                const separator = '='.repeat(80);\n                output += `${separator}\\n`;\n                output += `Absolute Path: ${file}\\n`;\n                output += `Relative Path: ${path.relative(folderPath, file)}\\n`;\n                output += `${separator}\\n\\n`;\n                output += content;\n                output += '\\n\\n';\n\n                processedFiles++;\n                progress.report({\n                    message: `Processing files... (${processedFiles}/${files.length})`,\n                    increment: (100 / files.length)\n                });\n            } catch (error) {\n                output += `Error reading file ${file}: ${error}\\n\\n`;\n            }\n        }\n\n        await fs.writeFile(outputPath, output, 'utf8');\n    });\n}\n\nasync function showSuccessMessage(outputFileName: string, outputPath: string): Promise<void> {\n    const action = await vscode.window.showInformationMessage(\n        `Successfully extracted context to ${outputFileName}`,\n        'Open File'\n    );\n\n    if (action === 'Open File') {\n        const doc = await vscode.workspace.openTextDocument(outputPath);\n        await vscode.window.showTextDocument(doc);\n    }\n}\n\nasync function getAllFiles(dirPath: string): Promise<string[]> {\n    const files: string[] = [];\n    \n    async function traverse(currentPath: string) {\n        const entries = await fs.readdir(currentPath, { withFileTypes: true });\n        \n        for (const entry of entries) {\n            const fullPath = path.join(currentPath, entry.name);\n            \n            // Skip node_modules and .git directories\n            if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {\n                await traverse(fullPath);\n            } else if (entry.isFile()) {\n                // You can add file extension filtering here if needed\n                files.push(fullPath);\n            }\n        }\n    }\n\n    await traverse(dirPath);\n    return files;\n}\n\nexport function deactivate() {}","module.exports = require(\"vscode\");","module.exports = require(\"fs/promises\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","console","log","disposable","vscode","commands","registerCommand","async","uri","selectedFiles","length","firstFile","folderPath","path","dirname","fsPath","outputFileName","Date","toISOString","replace","outputPath","join","processFiles","showSuccessMessage","window","showErrorMessage","fs","stat","isFile","basename","withProgress","location","ProgressLocation","Notification","title","cancellable","progress","output","files","dirPath","traverse","currentPath","entries","readdir","withFileTypes","entry","fullPath","name","isDirectory","startsWith","push","getAllFiles","report","message","structure","Map","forEach","file","relPath","relative","fileName","has","set","get","dir","fileList","processedFiles","content","readFile","separator","repeat","increment","error","writeFile","processFolderContent","subscriptions","rootPath","showInformationMessage","doc","workspace","openTextDocument","showTextDocument","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}