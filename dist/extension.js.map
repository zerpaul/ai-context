{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://aicontext/./src/extension.ts","webpack://aicontext/external commonjs \"vscode\"","webpack://aicontext/external node-commonjs \"fs/promises\"","webpack://aicontext/external node-commonjs \"path\"","webpack://aicontext/webpack/bootstrap","webpack://aicontext/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('AI Context Extractor is now active');\n\n    const disposable = vscode.commands.registerCommand('aicontext.extractFolder', async (uri: vscode.Uri, selectedFiles?: vscode.Uri[]) => {\n        try {\n            if (!uri) {\n                vscode.window.showErrorMessage('Please select a file or folder to extract context from');\n                return;\n            }\n\n            // Read user setting for whether or not to create a .txt file\n            const config = vscode.workspace.getConfiguration('aicontext');\n            const createTxtByDefault = config.get<boolean>('createTxtFileByDefault') === true;\n\n            const stats = await fs.stat(uri.fsPath);\n\n            // Handle folder case\n            if (stats.isDirectory()) {\n                const folderPath = uri.fsPath;\n                const folderName = path.basename(folderPath);\n                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n                const outputFileName = `${folderName}_${timestamp}.txt`;\n                const outputPath = path.join(folderPath, outputFileName);\n\n                await processFolderContent(folderPath, outputPath, createTxtByDefault);\n                if (createTxtByDefault) {\n                    await showFileCreationMessage(outputFileName, outputPath);\n                } else {\n                    await showClipboardOnlyMessage();\n                }\n                return;\n            }\n\n            // Handle file case(s)\n            const filesToProcess = selectedFiles || getSelectedFiles(uri);\n            const folderPath = path.dirname(uri.fsPath);\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            const outputFileName = filesToProcess.length > 1\n                ? `selected_files_${timestamp}.txt`\n                : `single_file_${timestamp}.txt`;\n            const outputPath = path.join(folderPath, outputFileName);\n\n            await processFiles(filesToProcess, outputPath, folderPath, createTxtByDefault);\n            if (createTxtByDefault) {\n                await showFileCreationMessage(outputFileName, outputPath);\n            } else {\n                await showClipboardOnlyMessage();\n            }\n\n        } catch (error) {\n            vscode.window.showErrorMessage(`Error extracting context: ${error}`);\n        }\n    });\n\n    context.subscriptions.push(disposable);\n}\n\nfunction getSelectedFiles(clickedUri: vscode.Uri): vscode.Uri[] {\n    // Get all selected files from the VS Code explorer\n    const selectedUris = vscode.window.activeTextEditor?.document\n        ? [vscode.window.activeTextEditor.document.uri]\n        : [];\n\n    // Get the current selection from the explorer\n    const explorerSelection = vscode.window.visibleTextEditors\n        .map(editor => editor.document.uri);\n\n    // Combine all selections\n    const allUris = [...selectedUris, ...explorerSelection];\n\n    // Add the clicked file if it's not already included\n    if (!allUris.some(uri => uri.fsPath === clickedUri.fsPath)) {\n        allUris.push(clickedUri);\n    }\n\n    // Remove duplicates and filter out non-file URIs\n    return Array.from(new Set(allUris))\n        .filter(uri => uri.scheme === 'file')\n        .map(uri => vscode.Uri.file(uri.fsPath));\n}\n\nasync function processFiles(\n    files: vscode.Uri[],\n    outputPath: string,\n    rootPath: string,\n    createTxtByDefault: boolean\n): Promise<void> {\n    await vscode.window.withProgress({\n        location: vscode.ProgressLocation.Notification,\n        title: \"Extracting file context...\",\n        cancellable: true\n    }, async (progress) => {\n        let output = 'FILE EXTRACTION\\n===============\\n';\n        output += `Root Path: ${rootPath}\\n`;\n        output += `Scan Date: ${new Date().toISOString()}\\n`;\n        output += `Total Files: ${files.length}\\n\\n`;\n\n        output += 'SELECTED FILES\\n==============\\n';\n        files.forEach(file => {\n            output += `${path.relative(rootPath, file.fsPath)}\\n`;\n        });\n        output += '\\n';\n\n        output += 'FILE CONTENTS\\n=============\\n\\n';\n\n        let processedFiles = 0;\n        for (const file of files) {\n            try {\n                const content = await fs.readFile(file.fsPath, 'utf8');\n                const separator = '='.repeat(80);\n                output += `${separator}\\n`;\n                output += `Absolute Path: ${file.fsPath}\\n`;\n                output += `Relative Path: ${path.relative(rootPath, file.fsPath)}\\n`;\n                output += `${separator}\\n\\n`;\n                output += content;\n                output += '\\n\\n';\n\n                processedFiles++;\n                progress.report({\n                    message: `Processing files... (${processedFiles}/${files.length})`,\n                    increment: (100 / files.length)\n                });\n            } catch (error) {\n                output += `Error reading file ${file.fsPath}: ${error}\\n\\n`;\n            }\n        }\n\n        // Write to file only if user setting is enabled\n        if (createTxtByDefault) {\n            await fs.writeFile(outputPath, output, 'utf8');\n        }\n        // Always copy to clipboard\n        await vscode.env.clipboard.writeText(output);\n    });\n}\n\nasync function processFolderContent(folderPath: string, outputPath: string, createTxtByDefault: boolean): Promise<void> {\n    await vscode.window.withProgress({\n        location: vscode.ProgressLocation.Notification,\n        title: \"Extracting folder context...\",\n        cancellable: true\n    }, async (progress) => {\n        let output = 'PROJECT METADATA\\n===============\\n';\n        output += `Project Root: ${folderPath}\\n`;\n        output += `Scan Date: ${new Date().toISOString()}\\n`;\n\n        const files = await getAllFiles(folderPath);\n        output += `Total Files: ${files.length}\\n\\n`;\n\n        progress.report({ message: \"Building directory structure...\" });\n\n        output += 'DIRECTORY STRUCTURE\\n==================\\n';\n        const structure = new Map<string, string[]>();\n\n        files.forEach(file => {\n            const relPath = path.relative(folderPath, path.dirname(file));\n            const fileName = path.basename(file);\n\n            if (!structure.has(relPath)) {\n                structure.set(relPath, []);\n            }\n            structure.get(relPath)?.push(fileName);\n        });\n\n        for (const [dir, fileList] of structure) {\n            output += dir ? `/${dir}/\\n` : '/\\n';\n            fileList.forEach(file => {\n                output += `  └── ${file}\\n`;\n            });\n        }\n        output += '\\n';\n\n        progress.report({ message: \"Reading file contents...\" });\n\n        output += 'FILE CONTENTS\\n=============\\n\\n';\n\n        let processedFiles = 0;\n        for (const file of files) {\n            try {\n                const content = await fs.readFile(file, 'utf8');\n                const separator = '='.repeat(80);\n                output += `${separator}\\n`;\n                output += `Absolute Path: ${file}\\n`;\n                output += `Relative Path: ${path.relative(folderPath, file)}\\n`;\n                output += `${separator}\\n\\n`;\n                output += content;\n                output += '\\n\\n';\n\n                processedFiles++;\n                progress.report({\n                    message: `Processing files... (${processedFiles}/${files.length})`,\n                    increment: (100 / files.length)\n                });\n            } catch (error) {\n                output += `Error reading file ${file}: ${error}\\n\\n`;\n            }\n        }\n\n        // Write to file only if user setting is enabled\n        if (createTxtByDefault) {\n            await fs.writeFile(outputPath, output, 'utf8');\n        }\n        // Always copy to clipboard\n        await vscode.env.clipboard.writeText(output);\n    });\n}\n\nasync function showFileCreationMessage(outputFileName: string, outputPath: string): Promise<void> {\n    const action = await vscode.window.showInformationMessage(\n        `Successfully extracted context to ${outputFileName} (and copied to clipboard).`,\n        'Open File'\n    );\n\n    if (action === 'Open File') {\n        const doc = await vscode.workspace.openTextDocument(outputPath);\n        await vscode.window.showTextDocument(doc);\n    }\n}\n\nasync function showClipboardOnlyMessage(): Promise<void> {\n    await vscode.window.showInformationMessage(\n        'Context copied to clipboard (no .txt file created).'\n    );\n}\n\nasync function getAllFiles(dirPath: string): Promise<string[]> {\n    const files: string[] = [];\n\n    async function traverse(currentPath: string) {\n        const entries = await fs.readdir(currentPath, { withFileTypes: true });\n\n        for (const entry of entries) {\n            const fullPath = path.join(currentPath, entry.name);\n\n            // Skip node_modules and .git directories\n            if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {\n                await traverse(fullPath);\n            } else if (entry.isFile()) {\n                // You can add file extension filtering here if needed\n                files.push(fullPath);\n            }\n        }\n    }\n\n    await traverse(dirPath);\n    return files;\n}\n\nexport function deactivate() {}\n","module.exports = require(\"vscode\");","module.exports = require(\"fs/promises\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","console","log","disposable","vscode","commands","registerCommand","async","uri","selectedFiles","window","showErrorMessage","createTxtByDefault","workspace","getConfiguration","get","fs","stat","fsPath","isDirectory","folderPath","outputFileName","path","basename","Date","toISOString","replace","outputPath","join","withProgress","location","ProgressLocation","Notification","title","cancellable","progress","output","files","dirPath","traverse","currentPath","entries","readdir","withFileTypes","entry","fullPath","name","startsWith","isFile","push","getAllFiles","length","report","message","structure","Map","forEach","file","relPath","relative","dirname","fileName","has","set","dir","fileList","processedFiles","content","readFile","separator","repeat","increment","error","writeFile","env","clipboard","writeText","processFolderContent","showFileCreationMessage","showClipboardOnlyMessage","filesToProcess","clickedUri","allUris","activeTextEditor","document","visibleTextEditors","map","editor","some","Array","from","Set","filter","scheme","Uri","getSelectedFiles","timestamp","rootPath","processFiles","subscriptions","showInformationMessage","doc","openTextDocument","showTextDocument","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}