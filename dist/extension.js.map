{"version":3,"file":"extension.js","mappings":"23BAIA,oBAAyBA,GACrBC,QAAQC,IAAI,sCAEZ,MAAMC,EAAaC,EAAOC,SAASC,gBAAgB,2BAA2BC,MAAOC,IACjF,GAAKA,EAKL,IACI,MAAMC,EAAaD,EAAIE,OAGjBC,EAAiB,GAFJC,EAAKC,SAASJ,OACf,IAAIK,MAAOC,cAAcC,QAAQ,QAAS,WAEtDC,EAAaL,EAAKM,KAAKT,EAAYE,GA8EzC,SA3EMP,EAAOe,OAAOC,aAAa,CAC7BC,SAAUjB,EAAOkB,iBAAiBC,aAClCC,MAAO,+BACPC,aAAa,IACdlB,MAAOmB,IAEN,IAAIC,EAAS,sCACbA,GAAU,iBAAiBlB,MAC3BkB,GAAU,eAAc,IAAIb,MAAOC,kBAGnC,MAAMa,QA6EtBrB,eAA2BsB,GACvB,MAAMD,EAAkB,GAmBxB,aAjBArB,eAAeuB,EAASC,GACpB,MAAMC,QAAgBC,EAAGC,QAAQH,EAAa,CAAEI,eAAe,IAE/D,IAAK,MAAMC,KAASJ,EAAS,CACzB,MAAMK,EAAWzB,EAAKM,KAAKa,EAAaK,EAAME,MAG1CF,EAAMG,gBAAkBH,EAAME,KAAKE,WAAW,MAAuB,iBAAfJ,EAAME,WACtDR,EAASO,GACRD,EAAMK,UAEbb,EAAMc,KAAKL,EAEnB,CACJ,CAEMP,CAASD,GACRD,CACX,CAlGoCe,CAAYlC,GAChCkB,GAAU,gBAAgBC,EAAMgB,aAEhClB,EAASmB,OAAO,CAAEC,QAAS,oCAG3BnB,GAAU,4CACV,MAAMoB,EAAY,IAAIC,IAEtBpB,EAAMqB,SAAQC,IACV,MAAMC,EAAUvC,EAAKwC,SAAS3C,EAAYG,EAAKyC,QAAQH,IACjDI,EAAW1C,EAAKC,SAASqC,GAE1BH,EAAUQ,IAAIJ,IACfJ,EAAUS,IAAIL,EAAS,IAE3BJ,EAAUU,IAAIN,IAAUT,KAAKY,EAAS,IAG1C,IAAK,MAAOI,EAAKC,KAAaZ,EAC1BpB,GAAU+B,EAAM,IAAIA,OAAW,MAC/BC,EAASV,SAAQC,IACbvB,GAAU,SAASuB,KAAQ,IAGnCvB,GAAU,KAEVD,EAASmB,OAAO,CAAEC,QAAS,6BAG3BnB,GAAU,mCAEV,IAAIiC,EAAiB,EACrB,IAAK,MAAMV,KAAQtB,EACf,IACI,MAAMiC,QAAgB5B,EAAG6B,SAASZ,EAAM,QAClCa,EAAY,IAAIC,OAAO,IAC7BrC,GAAU,GAAGoC,MACbpC,GAAU,kBAAkBuB,MAC5BvB,GAAU,kBAAkBf,EAAKwC,SAAS3C,EAAYyC,OACtDvB,GAAU,GAAGoC,QACbpC,GAAUkC,EACVlC,GAAU,OAEViC,IACAlC,EAASmB,OAAO,CACZC,QAAS,wBAAwBc,KAAkBhC,EAAMgB,UACzDqB,UAAY,IAAMrC,EAAMgB,QAEhC,CAAE,MAAOsB,GACLvC,GAAU,sBAAsBuB,MAASgB,OAC7C,OAIEjC,EAAGkC,UAAUlD,EAAYU,EAAQ,OAAO,IASnC,oBALMvB,EAAOe,OAAOiD,uBAC/B,qCAAqCzD,IACrC,aAGwB,CACxB,MAAM0D,QAAYjE,EAAOkE,UAAUC,iBAAiBtD,SAC9Cb,EAAOe,OAAOqD,iBAAiBH,EACzC,CAEJ,CAAE,MAAOH,GACL9D,EAAOe,OAAOsD,iBAAiB,oCAAoCP,IACvE,MA9FI9D,EAAOe,OAAOsD,iBAAiB,iDA8FnC,IAGJzE,EAAQ0E,cAAchC,KAAKvC,EAC/B,EAyBA,wBAA8B,EApI9B,kBACA,YACA,W,UCFAwE,EAAOC,QAAUC,QAAQ,S,UCAzBF,EAAOC,QAAUC,QAAQ,c,UCAzBF,EAAOC,QAAUC,QAAQ,O,GCCrBC,EAA2B,CAAC,ECE5BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaN,QAGrB,IAAID,EAASG,EAAyBG,GAAY,CAGjDL,QAAS,CAAC,GAOX,OAHAQ,EAAoBH,GAAUI,KAAKV,EAAOC,QAASD,EAAQA,EAAOC,QAASI,GAGpEL,EAAOC,OACf,CCnB0BI,CAAoB,K","sources":["webpack://aicontext/./src/extension.ts","webpack://aicontext/external commonjs \"vscode\"","webpack://aicontext/external node-commonjs \"fs/promises\"","webpack://aicontext/external node-commonjs \"path\"","webpack://aicontext/webpack/bootstrap","webpack://aicontext/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('AI Context Extractor is now active');\n\n    const disposable = vscode.commands.registerCommand('aicontext.extractFolder', async (uri: vscode.Uri) => {\n        if (!uri) {\n            vscode.window.showErrorMessage('Please select a folder to extract context from');\n            return;\n        }\n\n        try {\n            const folderPath = uri.fsPath;\n            const folderName = path.basename(folderPath);\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            const outputFileName = `${folderName}_${timestamp}.txt`;\n            const outputPath = path.join(folderPath, outputFileName);\n\n            // Show progress indicator\n            await vscode.window.withProgress({\n                location: vscode.ProgressLocation.Notification,\n                title: \"Extracting folder context...\",\n                cancellable: true\n            }, async (progress) => {\n                // Project metadata\n                let output = 'PROJECT METADATA\\n===============\\n';\n                output += `Project Root: ${folderPath}\\n`;\n                output += `Scan Date: ${new Date().toISOString()}\\n`;\n\n                // Get all files recursively\n                const files = await getAllFiles(folderPath);\n                output += `Total Files: ${files.length}\\n\\n`;\n\n                progress.report({ message: \"Building directory structure...\" });\n\n                // Directory structure\n                output += 'DIRECTORY STRUCTURE\\n==================\\n';\n                const structure = new Map<string, string[]>();\n                \n                files.forEach(file => {\n                    const relPath = path.relative(folderPath, path.dirname(file));\n                    const fileName = path.basename(file);\n                    \n                    if (!structure.has(relPath)) {\n                        structure.set(relPath, []);\n                    }\n                    structure.get(relPath)?.push(fileName);\n                });\n\n                for (const [dir, fileList] of structure) {\n                    output += dir ? `/${dir}/\\n` : '/\\n';\n                    fileList.forEach(file => {\n                        output += `  └── ${file}\\n`;\n                    });\n                }\n                output += '\\n';\n\n                progress.report({ message: \"Reading file contents...\" });\n\n                // File contents\n                output += 'FILE CONTENTS\\n=============\\n\\n';\n                \n                let processedFiles = 0;\n                for (const file of files) {\n                    try {\n                        const content = await fs.readFile(file, 'utf8');\n                        const separator = '='.repeat(80);\n                        output += `${separator}\\n`;\n                        output += `Absolute Path: ${file}\\n`;\n                        output += `Relative Path: ${path.relative(folderPath, file)}\\n`;\n                        output += `${separator}\\n\\n`;\n                        output += content;\n                        output += '\\n\\n';\n\n                        processedFiles++;\n                        progress.report({ \n                            message: `Processing files... (${processedFiles}/${files.length})`,\n                            increment: (100 / files.length)\n                        });\n                    } catch (error) {\n                        output += `Error reading file ${file}: ${error}\\n\\n`;\n                    }\n                }\n\n                // Write the output file\n                await fs.writeFile(outputPath, output, 'utf8');\n            });\n\n            // Show success message with option to open the file\n            const action = await vscode.window.showInformationMessage(\n                `Successfully extracted context to ${outputFileName}`,\n                'Open File'\n            );\n\n            if (action === 'Open File') {\n                const doc = await vscode.workspace.openTextDocument(outputPath);\n                await vscode.window.showTextDocument(doc);\n            }\n\n        } catch (error) {\n            vscode.window.showErrorMessage(`Error extracting folder context: ${error}`);\n        }\n    });\n\n    context.subscriptions.push(disposable);\n}\n\nasync function getAllFiles(dirPath: string): Promise<string[]> {\n    const files: string[] = [];\n    \n    async function traverse(currentPath: string) {\n        const entries = await fs.readdir(currentPath, { withFileTypes: true });\n        \n        for (const entry of entries) {\n            const fullPath = path.join(currentPath, entry.name);\n            \n            // Skip node_modules and .git directories\n            if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {\n                await traverse(fullPath);\n            } else if (entry.isFile()) {\n                // You can add file extension filtering here if needed\n                files.push(fullPath);\n            }\n        }\n    }\n\n    await traverse(dirPath);\n    return files;\n}\n\nexport function deactivate() {}","module.exports = require(\"vscode\");","module.exports = require(\"fs/promises\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","console","log","disposable","vscode","commands","registerCommand","async","uri","folderPath","fsPath","outputFileName","path","basename","Date","toISOString","replace","outputPath","join","window","withProgress","location","ProgressLocation","Notification","title","cancellable","progress","output","files","dirPath","traverse","currentPath","entries","fs","readdir","withFileTypes","entry","fullPath","name","isDirectory","startsWith","isFile","push","getAllFiles","length","report","message","structure","Map","forEach","file","relPath","relative","dirname","fileName","has","set","get","dir","fileList","processedFiles","content","readFile","separator","repeat","increment","error","writeFile","showInformationMessage","doc","workspace","openTextDocument","showTextDocument","showErrorMessage","subscriptions","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}