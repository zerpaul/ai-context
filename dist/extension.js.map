{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://aicontext/./src/extension.ts","webpack://aicontext/external commonjs \"vscode\"","webpack://aicontext/external node-commonjs \"fs/promises\"","webpack://aicontext/external node-commonjs \"path\"","webpack://aicontext/webpack/bootstrap","webpack://aicontext/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('AI Context Extractor is now active');\n\n    const disposable = vscode.commands.registerCommand('aicontext.extractFolder', async (uri: vscode.Uri, selectedUris?: vscode.Uri[]) => {\n        try {\n            if (!uri) {\n                vscode.window.showErrorMessage('Please select a file or folder to extract context from');\n                return;\n            }\n\n            // Read user setting for whether or not to create a .txt file\n            const config = vscode.workspace.getConfiguration('aicontext');\n            const createTxtByDefault = config.get<boolean>('createTxtFileByDefault') === true;\n            const ignoreFolderPaths = config.get<string[]>('ignoreFolderPaths') || [];\n\n            // If we're explicitly selecting a folder, check if it should be ignored\n            const stats = await fs.stat(uri.fsPath);\n            if (stats.isDirectory() && !selectedUris) {\n                const folderName = path.basename(uri.fsPath);\n                // Check if the folder name or path contains any of the ignore patterns\n                if (ignoreFolderPaths.some(pattern => \n                    folderName === pattern || \n                    folderName.includes(pattern) || \n                    uri.fsPath.includes(pattern)\n                )) {\n                    vscode.window.showInformationMessage(`Folder \"${folderName}\" matches an ignore pattern and was skipped.`);\n                    return;\n                }\n            }\n\n            // Determine if we have multiple items selected\n            const allItems = selectedUris || [uri];\n            \n            // Filter out any items that match ignore patterns\n            const filteredItems = await Promise.all(allItems.map(async item => {\n                const itemStats = await fs.stat(item.fsPath);\n                const itemName = path.basename(item.fsPath);\n                \n                if (itemStats.isDirectory() && \n                    ignoreFolderPaths.some(pattern => \n                        itemName === pattern || \n                        itemName.includes(pattern) || \n                        item.fsPath.includes(pattern)\n                    )) {\n                    return null; // This item should be ignored\n                }\n                return item;\n            }));\n            \n            // Remove null entries (ignored items)\n            const validItems = filteredItems.filter(item => item !== null) as vscode.Uri[];\n            \n            if (validItems.length === 0) {\n                vscode.window.showInformationMessage('All selected items match ignore patterns and were skipped.');\n                return;\n            }\n            \n            // Check if we have multiple items (files and/or folders)\n            if (validItems.length > 1) {\n                // Separate folders and files\n                const folders: vscode.Uri[] = [];\n                const files: vscode.Uri[] = [];\n                \n                for (const item of validItems) {\n                    const itemStats = await fs.stat(item.fsPath);\n                    if (itemStats.isDirectory()) {\n                        folders.push(item);\n                    } else {\n                        files.push(item);\n                    }\n                }\n                \n                // If we have multiple folders OR a mix of folders and files\n                if (folders.length > 0) {\n                    const rootPath = path.dirname(uri.fsPath);\n                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n                    const outputFileName = `multiple_items_${timestamp}.txt`;\n                    const outputPath = path.join(rootPath, outputFileName);\n                    \n                    await processMultipleItems(folders, files, outputPath, rootPath, createTxtByDefault);\n                    \n                    if (createTxtByDefault) {\n                        await showFileCreationMessage(outputFileName, outputPath);\n                    } else {\n                        await showClipboardOnlyMessage();\n                    }\n                    return;\n                } else {\n                    // Only multiple files, no folders\n                    const folderPath = path.dirname(files[0].fsPath);\n                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n                    const outputFileName = `selected_files_${timestamp}.txt`;\n                    const outputPath = path.join(folderPath, outputFileName);\n                    \n                    await processFiles(files, outputPath, folderPath, createTxtByDefault);\n                    \n                    if (createTxtByDefault) {\n                        await showFileCreationMessage(outputFileName, outputPath);\n                    } else {\n                        await showClipboardOnlyMessage();\n                    }\n                    return;\n                }\n            }\n            \n            // Handle single item (file or folder)\n            if (stats.isDirectory()) {\n                const folderPath = uri.fsPath;\n                const folderName = path.basename(folderPath);\n                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n                const outputFileName = `${folderName}_${timestamp}.txt`;\n                const outputPath = path.join(folderPath, outputFileName);\n\n                await processFolderContent(folderPath, outputPath, createTxtByDefault);\n                if (createTxtByDefault) {\n                    await showFileCreationMessage(outputFileName, outputPath);\n                } else {\n                    await showClipboardOnlyMessage();\n                }\n                return;\n            }\n\n            // Handle single file case\n            const filesToProcess = getSelectedFiles(uri);\n            const folderPath = path.dirname(uri.fsPath);\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            const outputFileName = filesToProcess.length > 1\n                ? `selected_files_${timestamp}.txt`\n                : `single_file_${timestamp}.txt`;\n            const outputPath = path.join(folderPath, outputFileName);\n\n            await processFiles(filesToProcess, outputPath, folderPath, createTxtByDefault);\n            if (createTxtByDefault) {\n                await showFileCreationMessage(outputFileName, outputPath);\n            } else {\n                await showClipboardOnlyMessage();\n            }\n\n        } catch (error) {\n            vscode.window.showErrorMessage(`Error extracting context: ${error}`);\n        }\n    });\n\n    context.subscriptions.push(disposable);\n}\n\n// Improved function to check if a path should be ignored based on ignoreFolderPaths\nfunction shouldIgnorePath(pathToCheck: string, ignoreFolderPaths: string[]): boolean {\n    const normalizedPath = pathToCheck.toLowerCase(); // Case-insensitive check\n    return ignoreFolderPaths.some(pattern => {\n        const normalizedPattern = pattern.toLowerCase();\n        return normalizedPath.includes(normalizedPattern);\n    });\n}\n\n// Check if a path is a child of another path\nfunction isChildPath(childPath: string, parentPath: string): boolean {\n    const relativePath = path.relative(parentPath, childPath);\n    return relativePath !== '' && !relativePath.startsWith('..') && !path.isAbsolute(relativePath);\n}\n\n// Helper function to get folder display name\nfunction getFolderDisplayName(folderPath: string, rootPath: string): string {\n    const relativePath = path.relative(rootPath, folderPath);\n    // If the relative path is empty, use the folder name instead\n    return relativePath || path.basename(folderPath);\n}\n\n// New function to process multiple items (folders and files)\nasync function processMultipleItems(\n    folders: vscode.Uri[],\n    files: vscode.Uri[],\n    outputPath: string,\n    rootPath: string,\n    createTxtByDefault: boolean\n): Promise<void> {\n    await vscode.window.withProgress({\n        location: vscode.ProgressLocation.Notification,\n        title: \"Extracting multiple items...\",\n        cancellable: true\n    }, async (progress) => {\n        // Get configuration settings\n        const config = vscode.workspace.getConfiguration('aicontext');\n        const ignoreFileExtensions = config.get<string[]>('ignoreFileExtensions') || [];\n        const ignoreFolderPaths = config.get<string[]>('ignoreFolderPaths') || [];\n        const ignoreFiles = config.get<string[]>('ignoreFiles') || [];\n        \n        let output = 'MULTIPLE ITEMS EXTRACTION\\n=======================\\n';\n        output += `Root Path: ${rootPath}\\n`;\n        output += `Scan Date: ${new Date().toISOString()}\\n`;\n        \n        // Keep track of all processed files to avoid duplicates\n        const processedFilePaths = new Set<string>();\n        const allFiles: { path: string, relativePath: string }[] = [];\n        const directoryStructure = new Map<string, string[]>();\n        \n        // First, list all selected folders\n        output += 'SELECTED ITEMS\\n==============\\n';\n        folders.forEach(folder => {\n            // Use the new helper function to get a proper display name\n            const displayName = getFolderDisplayName(folder.fsPath, rootPath);\n            output += `${displayName} (folder)\\n`;\n        });\n        \n        // Process folders\n        let processedFolders = 0;\n        \n        for (const folder of folders) {\n            const folderPath = folder.fsPath;\n            const folderName = path.basename(folderPath);\n            \n            progress.report({ \n                message: `Processing folder ${folderName}... (${processedFolders + 1}/${folders.length})`,\n                increment: folders.length > 0 ? (40 / folders.length) : 0\n            });\n            \n            // Get all files from this folder that aren't in ignored paths\n            const folderFiles = await getAllFiles(folderPath, ignoreFolderPaths, ignoreFileExtensions, ignoreFiles);\n            \n            // Add these files to our combined collection, avoiding duplicates\n            for (const file of folderFiles) {\n                if (!processedFilePaths.has(file)) {\n                    processedFilePaths.add(file);\n                    \n                    const relDir = path.relative(folderPath, path.dirname(file));\n                    const fileName = path.basename(file);\n                    \n                    // Get display name for the structure\n                    let structureKey = getFolderDisplayName(folderPath, rootPath);\n                    if (relDir) {\n                        structureKey = path.join(structureKey, relDir);\n                    }\n                    \n                    if (!directoryStructure.has(structureKey)) {\n                        directoryStructure.set(structureKey, []);\n                    }\n                    directoryStructure.get(structureKey)?.push(fileName);\n                    \n                    allFiles.push({\n                        path: file,\n                        relativePath: path.join(folderName, path.relative(folderPath, file))\n                    });\n                }\n            }\n            \n            processedFolders++;\n        }\n        \n        // Process individual files\n        const filteredFiles = files.filter(file => {\n            const filePath = file.fsPath;\n            const fileName = path.basename(filePath);\n            const fileExt = path.extname(fileName);\n            \n            // Skip files with extensions in ignoreFileExtensions\n            if (ignoreFileExtensions.includes(fileExt)) {\n                return false;\n            }\n            \n            // Skip files that match any of the ignoreFiles\n            if (ignoreFiles.some(ignoreFile => fileName === ignoreFile)) {\n                return false;\n            }\n            \n            // Skip files in folders that match any of the ignoreFolderPaths\n            if (shouldIgnorePath(filePath, ignoreFolderPaths)) {\n                return false;\n            }\n            \n            return true;\n        });\n        \n        // Add filtered files to selected items\n        filteredFiles.forEach(file => {\n            output += `${path.relative(rootPath, file.fsPath)}\\n`;\n        });\n        output += '\\n';\n        \n        // Add individual files to structure\n        for (const file of filteredFiles) {\n            if (!processedFilePaths.has(file.fsPath)) {\n                processedFilePaths.add(file.fsPath);\n                \n                const dirName = path.relative(rootPath, path.dirname(file.fsPath));\n                const fileName = path.basename(file.fsPath);\n                \n                if (!directoryStructure.has(dirName)) {\n                    directoryStructure.set(dirName, []);\n                }\n                directoryStructure.get(dirName)?.push(fileName);\n                \n                allFiles.push({\n                    path: file.fsPath,\n                    relativePath: path.relative(rootPath, file.fsPath)\n                });\n            }\n        }\n        \n        output += `Total Files: ${allFiles.length}\\n\\n`;\n        \n        // Add directory structure section (at the top as requested)\n        output += 'DIRECTORY STRUCTURE\\n==================\\n';\n        for (const [dir, fileList] of directoryStructure) {\n            output += dir ? `/${dir}/\\n` : '/\\n';\n            fileList.forEach(file => {\n                output += `  └── ${file}\\n`;\n            });\n        }\n        output += '\\n';\n        \n        // Add file contents section\n        output += 'FILE CONTENTS\\n=============\\n\\n';\n        \n        let processedFiles = 0;\n        const totalFiles = allFiles.length;\n        \n        for (const file of allFiles) {\n            try {\n                const content = await fs.readFile(file.path, 'utf8');\n                const separator = '='.repeat(80);\n                output += `${separator}\\n`;\n                output += `Absolute Path: ${file.path}\\n`;\n                output += `Relative Path: ${file.relativePath}\\n`;\n                output += `${separator}\\n\\n`;\n                output += content;\n                output += '\\n\\n';\n                \n                processedFiles++;\n                progress.report({\n                    message: `Processing files... (${processedFiles}/${totalFiles})`,\n                    increment: (60 / totalFiles)\n                });\n            } catch (error) {\n                output += `Error reading file ${file.path}: ${error}\\n\\n`;\n            }\n        }\n        \n        // Write to file only if user setting is enabled\n        if (createTxtByDefault) {\n            await fs.writeFile(outputPath, output, 'utf8');\n        }\n        // Always copy to clipboard\n        await vscode.env.clipboard.writeText(output);\n    });\n}\n\nfunction getSelectedFiles(clickedUri: vscode.Uri): vscode.Uri[] {\n    // Get all selected files from the VS Code explorer\n    const selectedUris = vscode.window.activeTextEditor?.document\n        ? [vscode.window.activeTextEditor.document.uri]\n        : [];\n\n    // Get the current selection from the explorer\n    const explorerSelection = vscode.window.visibleTextEditors\n        .map(editor => editor.document.uri);\n\n    // Combine all selections\n    const allUris = [...selectedUris, ...explorerSelection];\n\n    // Add the clicked file if it's not already included\n    if (!allUris.some(uri => uri.fsPath === clickedUri.fsPath)) {\n        allUris.push(clickedUri);\n    }\n\n    // Remove duplicates and filter out non-file URIs\n    return Array.from(new Set(allUris))\n        .filter(uri => uri.scheme === 'file')\n        .map(uri => vscode.Uri.file(uri.fsPath));\n}\n\nasync function processFiles(\n    files: vscode.Uri[],\n    outputPath: string,\n    rootPath: string,\n    createTxtByDefault: boolean\n): Promise<void> {\n    await vscode.window.withProgress({\n        location: vscode.ProgressLocation.Notification,\n        title: \"Extracting file context...\",\n        cancellable: true\n    }, async (progress) => {\n        // Get configuration settings\n        const config = vscode.workspace.getConfiguration('aicontext');\n        const ignoreFileExtensions = config.get<string[]>('ignoreFileExtensions') || [];\n        const ignoreFolderPaths = config.get<string[]>('ignoreFolderPaths') || [];\n        const ignoreFiles = config.get<string[]>('ignoreFiles') || [];\n        \n        // Filter files based on ignore settings\n        const filteredFiles = files.filter(file => {\n            const filePath = file.fsPath;\n            const fileName = path.basename(filePath);\n            const fileExt = path.extname(fileName);\n            \n            // Skip files with extensions in ignoreFileExtensions\n            if (ignoreFileExtensions.includes(fileExt)) {\n                return false;\n            }\n            \n            // Skip files that match any of the ignoreFiles\n            if (ignoreFiles.some(ignoreFile => fileName === ignoreFile)) {\n                return false;\n            }\n            \n            // Skip files in folders that match any of the ignoreFolderPaths\n            if (shouldIgnorePath(filePath, ignoreFolderPaths)) {\n                return false;\n            }\n            \n            return true;\n        });\n        \n        let output = 'FILE EXTRACTION\\n===============\\n';\n        output += `Root Path: ${rootPath}\\n`;\n        output += `Scan Date: ${new Date().toISOString()}\\n`;\n        output += `Total Files: ${filteredFiles.length}\\n\\n`;\n\n        output += 'SELECTED FILES\\n==============\\n';\n        filteredFiles.forEach(file => {\n            output += `${path.relative(rootPath, file.fsPath)}\\n`;\n        });\n        output += '\\n';\n        \n        // Directory structure section now at the top (before file contents)\n        output += 'DIRECTORY STRUCTURE\\n==================\\n';\n        const structure = new Map<string, string[]>();\n        \n        filteredFiles.forEach(file => {\n            const dirName = path.relative(rootPath, path.dirname(file.fsPath));\n            const fileName = path.basename(file.fsPath);\n            \n            if (!structure.has(dirName)) {\n                structure.set(dirName, []);\n            }\n            structure.get(dirName)?.push(fileName);\n        });\n        \n        for (const [dir, fileList] of structure) {\n            output += dir ? `/${dir}/\\n` : '/\\n';\n            fileList.forEach(file => {\n                output += `  └── ${file}\\n`;\n            });\n        }\n        output += '\\n';\n\n        output += 'FILE CONTENTS\\n=============\\n\\n';\n\n        let processedFiles = 0;\n        for (const file of filteredFiles) {\n            try {\n                const content = await fs.readFile(file.fsPath, 'utf8');\n                const separator = '='.repeat(80);\n                output += `${separator}\\n`;\n                output += `Absolute Path: ${file.fsPath}\\n`;\n                output += `Relative Path: ${path.relative(rootPath, file.fsPath)}\\n`;\n                output += `${separator}\\n\\n`;\n                output += content;\n                output += '\\n\\n';\n\n                processedFiles++;\n                progress.report({\n                    message: `Processing files... (${processedFiles}/${filteredFiles.length})`,\n                    increment: (100 / filteredFiles.length)\n                });\n            } catch (error) {\n                output += `Error reading file ${file.fsPath}: ${error}\\n\\n`;\n            }\n        }\n\n        // Write to file only if user setting is enabled\n        if (createTxtByDefault) {\n            await fs.writeFile(outputPath, output, 'utf8');\n        }\n        // Always copy to clipboard\n        await vscode.env.clipboard.writeText(output);\n    });\n}\n\nasync function processFolderContent(folderPath: string, outputPath: string, createTxtByDefault: boolean): Promise<void> {\n    await vscode.window.withProgress({\n        location: vscode.ProgressLocation.Notification,\n        title: \"Extracting folder context...\",\n        cancellable: true\n    }, async (progress) => {\n        // Get configuration settings\n        const config = vscode.workspace.getConfiguration('aicontext');\n        const ignoreFileExtensions = config.get<string[]>('ignoreFileExtensions') || [];\n        const ignoreFolderPaths = config.get<string[]>('ignoreFolderPaths') || [];\n        const ignoreFiles = config.get<string[]>('ignoreFiles') || [];\n        \n        let output = 'PROJECT METADATA\\n===============\\n';\n        output += `Project Root: ${folderPath}\\n`;\n        output += `Scan Date: ${new Date().toISOString()}\\n`;\n\n        const files = await getAllFiles(folderPath, ignoreFolderPaths, ignoreFileExtensions, ignoreFiles);\n        output += `Total Files: ${files.length}\\n\\n`;\n\n        progress.report({ message: \"Building directory structure...\" });\n\n        // Directory structure section at the top as requested\n        output += 'DIRECTORY STRUCTURE\\n==================\\n';\n        const structure = new Map<string, string[]>();\n\n        files.forEach(file => {\n            const relPath = path.relative(folderPath, path.dirname(file));\n            const fileName = path.basename(file);\n\n            if (!structure.has(relPath)) {\n                structure.set(relPath, []);\n            }\n            structure.get(relPath)?.push(fileName);\n        });\n\n        for (const [dir, fileList] of structure) {\n            output += dir ? `/${dir}/\\n` : '/\\n';\n            fileList.forEach(file => {\n                output += `  └── ${file}\\n`;\n            });\n        }\n        output += '\\n';\n\n        progress.report({ message: \"Reading file contents...\" });\n\n        output += 'FILE CONTENTS\\n=============\\n\\n';\n\n        let processedFiles = 0;\n        for (const file of files) {\n            try {\n                const content = await fs.readFile(file, 'utf8');\n                const separator = '='.repeat(80);\n                output += `${separator}\\n`;\n                output += `Absolute Path: ${file}\\n`;\n                output += `Relative Path: ${path.relative(folderPath, file)}\\n`;\n                output += `${separator}\\n\\n`;\n                output += content;\n                output += '\\n\\n';\n\n                processedFiles++;\n                progress.report({\n                    message: `Processing files... (${processedFiles}/${files.length})`,\n                    increment: (100 / files.length)\n                });\n            } catch (error) {\n                output += `Error reading file ${file}: ${error}\\n\\n`;\n            }\n        }\n\n        // Write to file only if user setting is enabled\n        if (createTxtByDefault) {\n            await fs.writeFile(outputPath, output, 'utf8');\n        }\n        // Always copy to clipboard\n        await vscode.env.clipboard.writeText(output);\n    });\n}\n\nasync function showFileCreationMessage(outputFileName: string, outputPath: string): Promise<void> {\n    const action = await vscode.window.showInformationMessage(\n        `Successfully extracted context to ${outputFileName} (and copied to clipboard)`,\n        'Open File'\n    );\n\n    if (action === 'Open File') {\n        const doc = await vscode.workspace.openTextDocument(outputPath);\n        await vscode.window.showTextDocument(doc);\n    }\n}\n\nasync function showClipboardOnlyMessage(): Promise<void> {\n    await vscode.window.showInformationMessage(\n        'Context copied to clipboard'\n    );\n}\n\nasync function getAllFiles(\n    dirPath: string, \n    ignoreFolderPaths: string[], \n    ignoreFileExtensions: string[], \n    ignoreFiles: string[]\n): Promise<string[]> {\n    const files: string[] = [];\n\n    async function traverse(currentPath: string) {\n        const entries = await fs.readdir(currentPath, { withFileTypes: true });\n\n        for (const entry of entries) {\n            const fullPath = path.join(currentPath, entry.name);\n            \n            if (entry.isDirectory()) {\n                // Skip hidden directories by default\n                if (entry.name.startsWith('.')) {\n                    continue;\n                }\n                \n                // Check if this folder should be ignored based on name or path\n                if (shouldIgnorePath(entry.name, ignoreFolderPaths) || \n                    shouldIgnorePath(fullPath, ignoreFolderPaths)) {\n                    continue;\n                }\n                \n                await traverse(fullPath);\n            } else if (entry.isFile()) {\n                // Skip files that match any of the ignoreFiles\n                if (ignoreFiles.some(file => entry.name === file)) {\n                    continue;\n                }\n                \n                // Skip files with extensions in ignoreFileExtensions\n                const fileExt = path.extname(entry.name);\n                if (ignoreFileExtensions.includes(fileExt)) {\n                    continue;\n                }\n                \n                // Skip files in folders that should be ignored\n                if (shouldIgnorePath(fullPath, ignoreFolderPaths)) {\n                    continue;\n                }\n                \n                files.push(fullPath);\n            }\n        }\n    }\n\n    await traverse(dirPath);\n    return files;\n}\n\nexport function deactivate() {}","module.exports = require(\"vscode\");","module.exports = require(\"fs/promises\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","console","log","disposable","vscode","commands","registerCommand","async","uri","selectedUris","window","showErrorMessage","config","workspace","getConfiguration","createTxtByDefault","get","ignoreFolderPaths","stats","fs","stat","fsPath","isDirectory","folderName","path","basename","some","pattern","includes","showInformationMessage","allItems","validItems","Promise","all","map","item","itemStats","itemName","filter","length","folders","files","push","rootPath","dirname","outputFileName","Date","toISOString","replace","outputPath","join","withProgress","location","ProgressLocation","Notification","title","cancellable","progress","ignoreFileExtensions","ignoreFiles","output","processedFilePaths","Set","allFiles","directoryStructure","Map","forEach","folder","displayName","getFolderDisplayName","processedFolders","folderPath","report","message","increment","folderFiles","getAllFiles","file","has","add","relDir","relative","fileName","structureKey","set","relativePath","filteredFiles","filePath","fileExt","extname","ignoreFile","shouldIgnorePath","dirName","dir","fileList","processedFiles","totalFiles","content","readFile","separator","repeat","error","writeFile","env","clipboard","writeText","processMultipleItems","showFileCreationMessage","showClipboardOnlyMessage","processFiles","structure","relPath","processFolderContent","filesToProcess","clickedUri","allUris","activeTextEditor","document","visibleTextEditors","editor","Array","from","scheme","Uri","getSelectedFiles","timestamp","subscriptions","pathToCheck","normalizedPath","toLowerCase","normalizedPattern","doc","openTextDocument","showTextDocument","dirPath","traverse","currentPath","entries","readdir","withFileTypes","entry","fullPath","name","startsWith","isFile","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}